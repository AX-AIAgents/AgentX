"""
Task Definitions Loader

Loads task definitions from JSONL files generated by the dataset_toolcall generator.
These are custom MCP-based tasks (not tau2-bench).
"""
import json
from pathlib import Path
from typing import Any


class TaskDefinition:
    """Represents a single task definition."""
    
    def __init__(self, data: dict[str, Any]):
        self.task_id = data.get("task_id", "unknown")
        self.domain = data.get("domain", "general")
        self.difficulty = data.get("difficulty", "medium")
        self.created_at = data.get("created_at")
        
        # Initial state for scoring
        self.initial_state = data.get("initial_state", {})
        
        # Kickoff message (what user wants)
        kickoff = data.get("kickoff_message", {})
        self.instruction = kickoff.get("content", "")
        self.kickoff_role = kickoff.get("role", "user")
        
        # Expected actions
        self.expected_actions = data.get("expected_actions", [])
        self.required_tools = [
            action["tool"] 
            for action in self.expected_actions 
            if action.get("required", True)
        ]
        
        # Success criteria for 3D scoring
        self.success_criteria = data.get("success_criteria", {})
        self.scoring_weights = data.get("scoring_weights", {
            "action": 0.4,
            "state": 0.5,
            "efficiency": 0.1
        })
        
        # Metadata
        self._meta = data.get("_meta", {})
        self.optimal_steps = self.success_criteria.get("efficiency", {}).get("optimal_steps", 
                                                                               len(self.required_tools))
        self.max_steps = self.success_criteria.get("efficiency", {}).get("max_steps", 
                                                                          self.optimal_steps * 2)
    
    def to_dict(self) -> dict[str, Any]:
        """Convert back to dictionary format."""
        return {
            "task_id": self.task_id,
            "domain": self.domain,
            "difficulty": self.difficulty,
            "instruction": self.instruction,
            "initial_state": self.initial_state,
            "expected_actions": self.expected_actions,
            "required_tools": self.required_tools,
            "success_criteria": self.success_criteria,
            "scoring_weights": self.scoring_weights,
            "optimal_steps": self.optimal_steps,
            "max_steps": self.max_steps,
        }
    
    def __repr__(self) -> str:
        return f"TaskDefinition(id={self.task_id}, domain={self.domain}, tools={len(self.required_tools)})"


class TaskLoader:
    """
    Loads and manages task definitions from JSONL files.
    
    Usage:
        loader = TaskLoader("path/to/task_definitions.jsonl")
        tasks = loader.load_all()
        task = loader.get_task(0)
        retail_tasks = loader.filter_by_domain("productivity")
    """
    
    def __init__(self, file_path: str | Path):
        self.file_path = Path(file_path)
        self._tasks: list[TaskDefinition] = []
        self._loaded = False
    
    def load_all(self) -> list[TaskDefinition]:
        """Load all tasks from the JSONL file."""
        if not self.file_path.exists():
            raise FileNotFoundError(f"Task definitions file not found: {self.file_path}")
        
        self._tasks = []
        with open(self.file_path, "r", encoding="utf-8") as f:
            for line_num, line in enumerate(f, 1):
                line = line.strip()
                if not line:
                    continue
                try:
                    data = json.loads(line)
                    task = TaskDefinition(data)
                    self._tasks.append(task)
                except json.JSONDecodeError as e:
                    print(f"⚠️ Skipping invalid JSON at line {line_num}: {e}")
                except Exception as e:
                    print(f"⚠️ Error parsing task at line {line_num}: {e}")
        
        self._loaded = True
        print(f"✅ Loaded {len(self._tasks)} tasks from {self.file_path.name}")
        return self._tasks
    
    def get_task(self, index: int) -> TaskDefinition:
        """Get task by index."""
        if not self._loaded:
            self.load_all()
        
        if index < 0 or index >= len(self._tasks):
            raise IndexError(f"Task index {index} out of range (0-{len(self._tasks)-1})")
        
        return self._tasks[index]
    
    def get_task_by_id(self, task_id: str) -> TaskDefinition | None:
        """Get task by its unique ID."""
        if not self._loaded:
            self.load_all()
        
        for task in self._tasks:
            if task.task_id == task_id:
                return task
        return None
    
    def filter_by_domain(self, domain: str) -> list[TaskDefinition]:
        """Filter tasks by domain."""
        if not self._loaded:
            self.load_all()
        
        return [t for t in self._tasks if t.domain.lower() == domain.lower()]
    
    def filter_by_difficulty(self, difficulty: str) -> list[TaskDefinition]:
        """Filter tasks by difficulty."""
        if not self._loaded:
            self.load_all()
        
        return [t for t in self._tasks if t.difficulty.lower() == difficulty.lower()]
    
    def get_domains(self) -> list[str]:
        """Get all unique domains in the task set."""
        if not self._loaded:
            self.load_all()
        
        return list(set(t.domain for t in self._tasks))
    
    def __len__(self) -> int:
        if not self._loaded:
            self.load_all()
        return len(self._tasks)
    
    def __iter__(self):
        if not self._loaded:
            self.load_all()
        return iter(self._tasks)


def load_custom_task(
    task_file: str | Path,
    task_index: int = 0,
) -> tuple[dict[str, Any], None]:
    """
    Load a custom task from JSONL file.
    
    Returns tuple matching tau2_adapter.load_task_from_tau2() signature
    for compatibility with existing Green Agent.
    
    Args:
        task_file: Path to task_definitions.jsonl
        task_index: Index of task to load
        
    Returns:
        Tuple of (task_dict, None) - None because we don't have tau2 env
    """
    loader = TaskLoader(task_file)
    task = loader.get_task(task_index)
    
    # Convert to dict format expected by Green Agent
    task_dict = {
        "id": task_index,
        "task_id": task.task_id,
        "instruction": task.instruction,
        "wiki": "",  # Custom tasks don't have wiki/policy
        "expected_state": task.initial_state,  # Initial state for tracking
        "evaluation_criteria": {
            "actions": task.expected_actions,
            "required_tools": task.required_tools,
        },
        "success_criteria": task.success_criteria,
        "scoring_weights": task.scoring_weights,
        "optimal_steps": task.optimal_steps,
        "max_steps": task.max_steps,
        "domain": task.domain,
        "difficulty": task.difficulty,
    }
    
    return task_dict, None
