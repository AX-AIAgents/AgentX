"""
Custom Task Green Agent Executor

A2A AgentExecutor implementation for custom MCP-based task evaluation.
This handles task definitions generated by dataset_toolcall generator.
"""
import json
import os
import re
from typing import Any

from a2a.server.agent_execution import AgentExecutor, RequestContext
from a2a.server.events import EventQueue
from a2a.utils import new_agent_text_message

from src.tools.task_loader import TaskLoader
from src.tools.mcp_scorer import MCPScorer
from src.user_simulator import UserSimulator

MCP_HOST = os.getenv("AGENT_PUBLIC_URL", "http://localhost:8091")


def parse_kickoff_message(message: str) -> dict[str, Any] | None:
    """Parse kickoff message with <task_config> XML tag."""
    match = re.search(r"<task_config>(.*?)</task_config>", message, re.DOTALL)
    if match:
        try:
            return json.loads(match.group(1).strip())
        except json.JSONDecodeError:
            return None
    return None


class GreenAgentExecutor(AgentExecutor):
    """
    A2A Executor for Green Agent with custom task definitions.
    
    Handles task definitions from JSONL files (not tau2-bench).
    Provides 3D scoring: Action Match, State Match, Efficiency.
    """

    def __init__(self, task_file: str | None = None):
        """
        Initialize with task definitions file.
        
        Args:
            task_file: Path to task_definitions.jsonl file
        """
        # Priority: argument > env var > default path
        default_path = "src/data/task_definitions.jsonl"
        self.task_file = task_file or os.getenv("TASK_DEFINITIONS_FILE", default_path)
        self.task_loader: TaskLoader | None = None
        
        # Current evaluation state
        self.current_task: dict[str, Any] | None = None
        self.current_domain = "general"
        self.user_simulator = None
        self.scorer: MCPScorer | None = None
        
        # Track state changes
        self.initial_state: dict[str, Any] = {}
        self.current_state: dict[str, Any] = {}
        
        # Load tasks if file provided
        if self.task_file:
            self._load_tasks()
    
    def _load_tasks(self) -> None:
        """Load task definitions from file."""
        if self.task_file:
            self.task_loader = TaskLoader(self.task_file)
            self.task_loader.load_all()
    
    async def setup_environment(self, task_index: int) -> dict[str, Any]:
        """
        Setup environment for a specific task (AgentBeats standard).
        
        This is the "Source of Truth" setup:
        1. Load task definition
        2. Reset MCP server state to initial_state
        3. Initialize User Simulator
        4. Initialize Scorer
        
        Args:
            task_index: Index of task in task file
            
        Returns:
            Task definition dict with metadata
        """
        if not self.task_loader:
            raise RuntimeError("Task loader not initialized. Provide task_file.")
        
        # 1. Load task definition
        task_def = self.task_loader.get_task(task_index)
        
        # 2. Reset MCP server to initial state (Reproducibility)
        reset_success = await self._send_task_to_mcp(task_def.to_dict())
        if not reset_success:
            print("‚ö†Ô∏è Warning: Failed to reset MCP state, continuing anyway...")
        
        # 3. Store task and initialize state tracking
        self.current_task = task_def.to_dict()
        self.current_domain = task_def.domain
        self.initial_state = task_def.initial_state.copy()
        self.current_state = task_def.initial_state.copy()
        
        # 4. Initialize Scorer (3D: action, argument, efficiency)
        self.scorer = MCPScorer(task_def.to_dict())
        
        # 5. Initialize User Simulator (for interjections)
        simulation_events = self.current_task.get("simulation_events", [])
        self.user_simulator = UserSimulator(simulation_events)
        
        print(f"‚úÖ Environment ready: {task_def.task_id} ({task_def.domain})")
        print(f"   Initial state: {list(self.initial_state.keys())}")
        print(f"   Required tools: {task_def.required_tools}")
        
        return {
            "task_id": task_def.task_id,
            "domain": task_def.domain,
            "difficulty": task_def.difficulty,
            "initial_state": self.initial_state,
            "ready": True
        }
    
    async def execute(
        self,
        context: RequestContext,
        event_queue: EventQueue,
    ) -> None:
        """Handle incoming A2A request."""
        user_message = self._extract_user_message(context)
        
        # Check for kickoff message
        config = parse_kickoff_message(user_message)
        
        if config:
            response = await self._handle_kickoff(config)
        else:
            response = await self._handle_message(user_message)
        
        await event_queue.enqueue_event(new_agent_text_message(response))

    async def cancel(
        self,
        context: RequestContext,
        event_queue: EventQueue,
    ) -> None:
        """Handle cancel request."""
        await event_queue.enqueue_event(
            new_agent_text_message("Evaluation cancelled")
        )

    def _extract_user_message(self, context: RequestContext) -> str:
        """Extract user message from request context."""
        if context.message and context.message.parts:
            for part in context.message.parts:
                if hasattr(part, "root") and hasattr(part.root, "text"):
                    return part.root.text
        return ""

    async def _handle_kickoff(self, config: dict[str, Any]) -> str:
        """
        Handle kickoff message to start evaluation.
        
        A2A Mode: Green Agent connects to Purple Agent and orchestrates evaluation.
        
        Config format:
        {
            "purple_agent_url": "http://localhost:9000",
            "task_file": "path/to/task_definitions.jsonl",
            "task_index": 0,
            "max_turns": 30
        }
        """
        purple_agent_url = config.get("purple_agent_url")
        
        if not purple_agent_url:
            return json.dumps({
                "status": "error",
                "message": "purple_agent_url is required. Use run.py with --external-agent flag.",
            })
        
        return await self._handle_full_orchestration(config)

    async def _get_tool_schemas(self) -> list[dict[str, Any]]:
        """Get tool schemas from MCP server."""
        import httpx
        
        try:
            mcp_base = MCP_HOST.replace("/mcp", "")
            async with httpx.AsyncClient(timeout=5.0) as client:
                response = await client.get(f"{mcp_base}/tools")
                if response.status_code == 200:
                    return response.json().get("tools", [])
        except Exception:
            pass
        
        return []

    async def _send_task_to_mcp(self, task: dict[str, Any]) -> bool:
        """Send current task to MCP server to initialize mock state."""
        import httpx
        
        try:
            mcp_base = MCP_HOST.replace("/mcp", "")
            async with httpx.AsyncClient(timeout=5.0) as client:
                response = await client.post(
                    f"{mcp_base}/task",
                    json=task
                )
                if response.status_code == 200:
                    result = response.json()
                    print(f"üì¶ Task sent to MCP: {result.get('task_id', 'unknown')}")
                    return True
        except Exception as e:
            print(f"‚ö†Ô∏è Failed to send task to MCP: {e}")
        
        return False

    async def _get_final_state_from_mcp(self) -> dict[str, Any]:
        """Get final state from MCP server for scoring."""
        import httpx
        
        try:
            mcp_base = MCP_HOST.replace("/mcp", "")
            async with httpx.AsyncClient(timeout=5.0) as client:
                response = await client.get(f"{mcp_base}/state")
                if response.status_code == 200:
                    data = response.json()
                    return data.get("state", {})
        except Exception as e:
            print(f"‚ö†Ô∏è Failed to get state from MCP: {e}")
        
        return {}

    async def _reset_mcp_state(self) -> bool:
        """Reset MCP server state."""
        import httpx
        
        try:
            mcp_base = MCP_HOST.replace("/mcp", "")
            async with httpx.AsyncClient(timeout=5.0) as client:
                response = await client.post(f"{mcp_base}/reset")
                return response.status_code == 200
        except Exception:
            pass
        
        return False

    async def _handle_message(self, message: str) -> str:
        """
        Handle regular message - DEPRECATED.
        
        In A2A mode, all communication goes through GreenAgentOrchestrator.
        This method only exists for backwards compatibility.
        """
        return json.dumps({
            "status": "error",
            "message": "Direct message handling is deprecated. Use A2A orchestration mode with purple_agent_url.",
        })

    def record_tool_call(self, tool_name: str, arguments: dict[str, Any], result: Any = None) -> None:
        """
        Public method to record tool calls.
        
        Called by MCP server when agent makes tool calls.
        """
        if self.scorer:
            self.scorer.record_tool_call(tool_name, arguments, result)
            self._apply_state_mutation(tool_name, arguments, result)
    
    def _apply_state_mutation(
        self, 
        tool_name: str, 
        args: dict[str, Any], 
        result: Any = None
    ) -> None:
        """Apply state mutation based on tool call."""
        # Basic state tracking - extend based on your tools
        domain = tool_name.split("-")[0].lower() if "-" in tool_name else "general"
        
        if domain not in self.current_state:
            self.current_state[domain] = {}
        
        # Track that this tool was called
        if "tool_calls" not in self.current_state[domain]:
            self.current_state[domain]["tool_calls"] = []
        
        self.current_state[domain]["tool_calls"].append({
            "tool": tool_name,
            "args": args,
        })
    
    def _calculate_score(self, final_state: dict[str, Any] | None = None) -> dict[str, Any]:
        """Calculate final score using MCPScorer."""
        if not self.scorer:
            return {
                "success": False,
                "total_score": 0.0,
                "error": "No scorer initialized",
            }
        
        # Use provided final_state or fall back to current_state
        state_to_score = final_state or self.current_state
        
        result = self.scorer.calculate_score(state_to_score)
        score_dict = result.to_dict()
        
        # Add metadata
        score_dict["task_id"] = self.current_task.get("task_id") if self.current_task else None
        score_dict["domain"] = self.current_domain
        score_dict["turns"] = len(self.user_simulator.conversation_history) // 2 if self.user_simulator else 0
        
        return score_dict
    
    async def _calculate_score_async(self) -> dict[str, Any]:
        """Calculate score with final state from MCP server."""
        # Get final state from MCP server
        final_state = await self._get_final_state_from_mcp()
        
        # Merge with local state (MCP state takes precedence)
        merged_state = {**self.current_state, **final_state}
        
        return self._calculate_score(merged_state)
    
    def reset(self) -> None:
        """Reset state for new evaluation."""
        self.current_task = None
        self.scorer = None
        self.initial_state = {}
        self.current_state = {}
        if self.user_simulator:
            self.user_simulator.reset()

    async def _handle_full_orchestration(self, config: dict[str, Any]) -> str:
        """
        Handle FULL A2A orchestration mode.
        
        This is the proper A2A architecture:
        1. Green Agent receives kickoff from run.py
        2. Green Agent connects to Purple Agent
        3. Green Agent runs entire evaluation loop
        4. Green Agent returns results
        
        NO MORE run.py orchestration - Green Agent does everything!
        """
        from src.green_agent_orchestrator import GreenAgentOrchestrator
        
        purple_agent_url = config["purple_agent_url"]
        task_file = config.get("task_file") or self.task_file
        task_ids = config.get("task_ids")
        max_turns = config.get("max_turns", 30)
        
        # Handle single task_index
        if "task_index" in config and not task_ids:
            task_ids = [config["task_index"]]
        
        if not task_file:
            return json.dumps({
                "status": "error",
                "message": "No task file specified",
            })
        
        print(f"\nüéØ A2A Orchestration Mode Activated!")
        print(f"   Purple Agent: {purple_agent_url}")
        print(f"   Task File: {task_file}")
        print(f"   Tasks: {task_ids or 'first 5'}")
        
        try:
            # Create orchestrator
            orchestrator = GreenAgentOrchestrator(
                task_file=task_file,
                mcp_endpoint=MCP_HOST,
            )
            
            # Run full evaluation
            results = await orchestrator.evaluate_agent(
                purple_agent_url=purple_agent_url,
                task_ids=task_ids,
                max_turns=max_turns,
            )
            
            return json.dumps(results, indent=2, default=str)
            
        except Exception as e:
            import traceback
            print(f"‚ùå Orchestration error: {e}")
            traceback.print_exc()
            return json.dumps({
                "status": "error",
                "message": str(e),
                "traceback": traceback.format_exc(),
            })
